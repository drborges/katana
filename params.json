{"name":"Katana","tagline":"Dependency Injection package driven by provider functions","body":"# Katana [![Build Status](https://travis-ci.org/drborges/katana.svg?branch=master)](https://travis-ci.org/drborges/katana)\r\n\r\nDependency Injection package driven by provider functions\r\n\r\n## Brief Overview\r\n\r\nkatana approaches DI in a fairly simple manner. For each type that needs to be available for injection a provider function needs to be implemented and registered with an instance of `kanata.Injector`. Providers construct instances of a particular type a.k.a `Injectable` and can be of two types: `katana.TypeNew` and `katana.TypeSingleton`.\r\n\r\nProvider functions are like [constructor functions](https://golang.org/doc/effective_go.html#composite_literals), they may take arguments representing the required dependencies to create an instance of that injectable and return a single value, the actual instance. Here is an example:\r\n\r\n```go\r\nfunc NewUserService(depA *DependencyA, depB *DependencyB) *UserService {\r\n\treturn &UserService{depA, depB}\r\n}\r\n```\r\n\r\nOnce a provider is registered the corresponding injectable can be resolved and injected as dependency into other injectable providers, or even into arbitrary functions. Lets see how that translates into code:\r\n\r\n```go\r\n// Get an instance of katana's injector\r\ninjector := katana.New()\r\n\r\n// Register the provider of *UserService with the injector\r\ninjector.ProvideNew(&UserService{}, NewUserService)\r\n\r\n// Grab a new instance of *UserService with all its dependencies injected\r\nvar service *UserService\r\ninjector.Resolve(&service)\r\n```\r\n\r\nKatana will detect and panic upon any eventual `cyclic dependency` when resolving an injectable, providing the cyclic dependency graph so you can easily troubleshoot.\r\n\r\n## Example\r\n\r\nLets say you have the following types each with their own dependencies:\r\n\r\n```go\r\ntype Config struct {\r\n\tDatastoreURL string\r\n\tCacheTTL     int\r\n\tDebug        bool\r\n}\r\n\r\ntype Cache struct {\r\n\tTTL int\r\n}\r\n\r\ntype Datastore struct {\r\n\tCache *Cache\r\n\tURL   string\r\n}\r\n\r\ntype AccountService struct {\r\n\tDatastore *Datastore\r\n}\r\n```\r\n\r\nA provider for each type of injectable is created and registered with a new instance of `katana.Injector`\r\n\r\n```go\r\n// Grabs a new instance of katana.Injector\r\ninjector := katana.New()\r\n\r\n// Registers a provider for config. Katana will resolve dependencies on Config by\r\n// setting them to this particular instance.\r\ninjector.Provide(Config{\r\n\tDatastoreURL: \"https://myawesomestartup.com/db\",\r\n\tCacheTTL:     20000,\r\n})\r\n\r\n// Registers a provider for *Cache whose result is never cached, which means\r\n// different requests for an instance of *Cache will yield different instances.\r\ninjector.ProvideNew(&Cache{}, func(config Config) *Cache {\r\n\treturn &Cache{config.CacheTTL}\r\n})\r\n\r\n// Registers a provider for *Datastore with all its dependencies (Config, *Cache)\r\n// being resolved and injected into the provider function.\r\ninjector.ProvideNew(&Datastore{}, func(config Config, cache *Cache) *Datastore {\r\n\treturn &Datastore{cache, config.DatastoreURL}\r\n})\r\n\r\n// Registers a singleton provider for *AccountService. The instance provided by\r\n// a singleton provider is cached so further requests yield the same result.\r\ninjector.ProvideSingleton(&AccountService{}, func(db *Datastore) *AccountService {\r\n\treturn &AccountService{db}\r\n})\r\n```\r\n\r\nFinally you can get instances of the provided `injectables` with all their dependencies -- if any -- resolved:\r\n\r\n```go\r\nvar service1, service2 *AccountService\r\nvar db1, db2 *Datastore\r\nvar cache1, cache2 *Cache\r\nvar config Config\r\n\r\n// Katana allows you to resolve multiple instances on a single \"shot\"\r\n// \r\n// Note that:\r\n// 1. service1 == service2: *AccountService provider is a singleton\r\n// 2. db1 != db2: *Datastore injectable is not singleton\r\n// 3. cache1 != cache2: *Cache is not a singleton\r\n// 4. config will point to the Config instance defined in the previous code block, since it was provided using Injector#Provide method.\r\ninjector.Resolve(&service1, &service2, &db1, &db2, &cache1, &cache2, &config)\r\n```\r\n\r\n# Thread-Safety\r\n\r\nIn order to use `katana` in a `multi-thread` environment you should use a copy of the injector per thread.\r\n\r\nCopies of `katana.Injector` can be created using `Injector.Clone()`. This copy will have all the registered providers of the original injector and every new provider registered in the new copy will not be available to other copies of `katana.Injector`.\r\n\r\n**Note** Singleton providers will still yield the same instances across different threads.\r\n\r\n### Example: HTTP Server\r\n\r\nAssuming we have the injector instance from the example above ^\r\n\r\n```go\r\nhttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\r\n\tvar service *AccountService\r\n\tinjector.Clone().Provide(w, r).Resolve(&service)\r\n})\r\n\r\nlog.Fatal(http.ListenAndServe(\":8080\", nil))\r\n```\r\n\r\n# Injecting Function Arguments\r\n\r\nKatana also allows you to inject arguments into functions (that is how it resolves the arguments of a injectable provider):\r\n\r\n```go\r\nfetchAllAccounts := injector.Inject(func(srv *AccountService, conf Config) ([]*Account, error) {\r\n\tif conf.Debug {\r\n\t\treturn mocks.Accounts(), nil\r\n\t}\r\n\treturn srv.Accounts()\r\n})\r\n```\r\n\r\n`Injector#Inject` returns a closure holding all the resolved function arguments and when called returns a `katana.Output` with the function returning values.\r\n\r\n```go\r\nif result := fetchAllAccounts(); !result.Empty() {\r\n\taccounts, err := result[0], result[1]\r\n}\r\n```\r\n\r\n# Contributing\r\n\r\n# License","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}